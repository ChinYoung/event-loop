# Eventloop

## js的单线程

- 我们都知道, js是一种单线程, 异步非阻塞的编程语言, 在更进一步之前, 我们需要先了解一下浏览器.
  - 浏览器环境是多进程的, 主要包含了
    - 主进程, 负责管理其他进程, 如资源的下载, 浏览器界面的展示等
    - GPU进程, 用于3D绘制
    - 渲染进程, 也就是跟我们打交道最多的进程, 内部是多线程的, 主要包含:
      - GUI渲染线程
      - js引擎线程
      - 事件触发线程
      - 定时器触发线程
      - http请求线程
  - 需要注意的是, GUI渲染线程和js引擎线程是互斥的, js引擎执行时, GUI线程就会被挂起
    - 通常来说, 浏览器会尝试以60hz(通常的操作系统的刷新频率, 但使用高刷新率的显示屏时浏览器是否会以同样的频率进行刷新还需要进一步验证)的频率更新页面, 即一秒钟更新60帧, 约16.6ms更新一次, 但更新时机由浏览器决定, 即更新时机并不确定
    - GUI更新会被保存在一个队列中, 在js引擎空闲时执行
    - 综上, 浏览器会尝试以60hz的频率更新页面, 而js引擎的执行可能会导致渲染被推迟, 而更长时间的阻塞甚至会导致浏览器无法按照60hz的频率刷新页面, 即产生"丢帧", 页面即会有"卡顿"的感觉
      - **这也就是性能指标RAIL中I的由来, 当js引擎idle的时间越久, 浏览器便越容易达成60hz的渲染目标, 用户看到的页面也便越流畅**
  - js引擎并不负责如`setTimeout`, `http请求`等任务的执行, 这听起来有点奇怪, 但确实是这样的, 这些任务是由浏览器的其他进程执行的, 这样的任务我们可以统称为`Web API`
    - 当我们调用这些api时, js引擎会调用浏览器的底层接口, 并初始化一个任务, 由其他线程负责"监视", 当任务完成时, 再通知js引擎:该任务已经完成了, 可以进行下一步
      - 在nodejs中也是类似的, 但是nodejs端的js引擎不是运行于浏览器的, `Web API`调用的是操作系统的api
    - 这个"下一步", 就是我们调用api时提供的`回调函数`, 接下来, js引擎就会在适当的时机执行该`回调函数`
    - js被称为"异步非阻塞"的编程语言主要也就是这个原因, 通常像http请求这样的任务, 无法立即得到执行结果并返回给调用者, 此时如果继续停留并等待, 则后续的所有任务都需要等待(即所谓的"阻塞"), 因此js引擎将该任务交由其他线程执行后立即返回, 该任务不会在js引擎线程中执行, 因此我们称js是异步且非阻塞的

## js的内存模型

- js的内存模型可以理解为两个不同区域: `调用栈`和`堆`
